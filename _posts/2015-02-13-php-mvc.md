---
layout: post
title: MVC项目灵活分层
categories: code
---

MVC大家都懂，但是新手往往被MVC牵着走，把所有业务逻辑都写到M里面，甚至是C里面。 这是一个很严重的错误。 会导致项目高度耦合，而变得无法维护。 我觉得不要桎梏于MVC, 而是应该在MVC的基础上按照你的项目来灵活划分层次. 下面是我一个项目的分层:

基于MVC再分一层**业务逻辑层**来处理业务逻辑和一层**缓存层**来管理站点缓存:

- **控制层**： 只负责接收、过滤请求参数 和 调用逻辑、数据模型获取返回数据,整理返回数据传递给视图层
- **逻辑层**： 负责调用模型层、业务逻辑层，完成业务逻辑，然后把结果返回给控制器。
(!逻辑层不要直接输出,逻辑层采用异常来进行错误返回,逻辑层类是按业务逻辑块来划分)
- **数据层**： 数据层类映射数据库表（orm）, 并且数据类也可以表示实体。
- **缓存层**： 缓存key管理类（静态类，用来管理站点的缓存key生成）,以及其他业务缓存类.

下面是一个伪代码示例:

	class appController{
		function dealApp(){
			//get resquest
			$appPackage = filter_var($_POST['package']);
			//built params obj
			$paramsObj = new stdclass;
			$paramsObj->appPackage = $appPackage;
			$this->app = new appLogicModel;
			$this->app->parseApp($paramsObj);
			$this->app->md5App();
			//response result
		}
	}
	//app处理逻辑模型
	class appLogicModel(){
		function __construct(){
			$this->app = new appOrmModel;
			$this->appVersion = new appVersionOrmModel;
		}
	    //app相关业务逻辑
		//解析app
		function parseApp(){}
		//生成app的md5
		function md5App(){}
		//
		function getAppList(){
			$statusDesc = appOrmModel::fieldEnum('status');
		}
	}
	//orm扮演数据访问和表实体的角色
	class appOrmModel(){
		//实体常量
		const status_on = 1;
		const status_off = 2;
		static function fieldEnum($field){
			$enum = array(
					'status'=>array(
							self::status_on => '启用'，
							self::status_off => '禁用'
						)
				);
			return $enum[$field];
		}
		//数据库访问方法
		function select(){}
		function query(){}
		//实体方法
		function getAppInfoById(){}
		function getAppTitleByName(){}
	}
